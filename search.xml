<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker指令]]></title>
    <url>%2F2018%2F07%2F09%2Fdocker%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[RUN构建容器时执行的命令 有两种格式 RUN –基本的linux指令 RUN [“executable”, “param1”, “param2”] –executable可以理解为可行执行文件，后面就是两个参数 CMD功能为容器启动时要运行的命令，在构件时并不运行 传递的参数一定要是双引号。docker解析的是一个JSON array LABLE功能是为镜像指定标签 LABLE = = … 换行可以使用\符号 LABEL multi.label1=”value1” \ multi.label2=”value2” 说明：LABEL会继承基础镜像种的LABEL，如遇到key相同，则值覆盖 ENV设置环境变量 ENV ENV = … 两者的区别就是第一种是一次设置一个，第二种是一次设置多个 ADD一个复制命令，把文件复制到镜像中 如果把虚拟机与容器当做两台linux服务器的话，命令就类似于scp，只是scp需要用户名和密码验证，而ADD不用 ADD ….. ADD [““,…”“] 路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径 可以是一个本地文件或者是一个本地压缩文件，还可以是一个url 如果把写成一个url，那么ADD就类似于wget命令 COPY复制 COPY ….. COPY [““,…”“] 与ADD的区别 COPY的只能是本地文件，其他用法一致 ENTRYPOINT功能是启动时的默认命令 ENTRYPOINT [“executable”, “param1”, “param2”] ENTRYPOINT command param1 param2 VOLUME可实现挂载功能,可以将内地文件夹或者其他容器得文件夹挂在到这个容器中 VOLUME [“/data”] jenkins实现docker项目的自动部署Poll SCM的功能是每隔一定时间检查源码是否更新。有的话就自动构建 /60 * 含义是每隔60分钟检查一次git源码]]></content>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql杂谈]]></title>
    <url>%2F2018%2F04%2F03%2Fmysql%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[常用的进程间通信方式有:管道，命名管道，命名字，TCP套接字，Unix域套接字。而Mysql提供的连接方式从本质上看都是上述提及的进程通信方式 TCP/IP TCP/IP套接字的方式是MySQL在任何平台上都提供的连接方式，也是用的最多的。一般情况客户端一台机器去连接服务器另一台机器。两台机器之间就是通过TCP/IP连接。客户端会向服务器Mysql实例发出TCP/IP连接请求，连接成功 命名管道和共享内存 Windows2003，vista及在此之上的平台，如果两个需要进程通信的进程在同一台机器上，那么可以使用命名管道，配置文件启用—enable-named-pipe。也可以使用共享内存的连接方式，只需要进行配置 在与数据库进行交互操作的时候一些时间资源的比较 123456789101112131415161718192021222324252627/** * 测试数据库连接对象消耗的时间 */String sql = "select * from mybatis WHERE id = ?";PreparedStatement preparedStatement = null;ResultSet resultSet = null;long beforeTimeOffset = 0; //创建Connection对象前时间long afterTimeOffset = 0L; //创建Connection对象后时间long executeTimeOffset = 0; //创建Connection对象后时间// 这是和数据库连接的对象，这就是资源Connection connection = null;Class.forName("com.mysql.jdbc.Driver");beforeTimeOffset = System.currentTimeMillis();System.out.println(beforeTimeOffset);connection = DriverManager.getConnection("jdbc:mysql://rm-bp18t9bzt23446tlvo.mysql.rds.aliyuncs.com:3306/activemq_authorization", "root", "Lgeekrds2017");afterTimeOffset = System.currentTimeMillis();System.out.println(afterTimeOffset);System.out.println("create cost:" + (afterTimeOffset - beforeTimeOffset));preparedStatement = connection.prepareStatement(sql);System.out.println("precompile cost:" + (System.currentTimeMillis() - afterTimeOffset));preparedStatement.setObject(1, 1L);resultSet = preparedStatement.executeQuery();System.out.println("execute cost:" + (System.currentTimeMillis()-afterTimeOffset)); 从此图可知，创建一个Connection对象，用了毫秒，而真正执行sql的时间却只有毫秒 一个connection对象的创建代价可以说是相当大，试想一下，如果我们在web应用中，为用户的每一个请求就操作一次数据库，当有10000个在线用户并发操作之后，对计算机而言，仅仅是创建connection对象的时间就要]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis书籍观后感-2]]></title>
    <url>%2F2018%2F04%2F02%2Fmybatis%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F-2%2F</url>
    <content type="text"><![CDATA[MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。文档的顶层结构如下（顺序也不能变）： configuration 配置 properties 属性 settings 设置 typeAliases 类型命名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次辛苦的在网关，客户端和服务端找乱码bug的问题]]></title>
    <url>%2F2018%2F04%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BE%9B%E8%8B%A6%E7%9A%84%E5%9C%A8%E7%BD%91%E5%85%B3%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%89%BE%E4%B9%B1%E7%A0%81bug%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[乱码问题的起因和解决的过程，以及设计到的一些知识（附录有本人对字符编码和字符集的理解）由于最近公司准备开发属于自己的网关。作为服务端的我需要和网关开发人员进行协议的制定和对接。 通信协议我们使用的是MQTT 网关人员在设备连接上线的时候会上报网关设备以及网关设备下面挂载的子设备信息，其中包括了设备的名称，有些是英文的，有些是中文的。 作为服务端的我这边接收到了对应的消息，我就会把对应的设备数据存储进mysql数据库存储起来。在这之间通信的数据的编码都是”UTF-8”。在我们调通之后，数据库里面的数据中文是正常显示的，但是在断网重连重新上报的时候竟然出现了乱码的字段。反复试了几次，乱码和不乱码的情况都会发生 客户端(网关端)和服务端编码的方式要一致 因为这段代码是一个已经离职的同事写的 12byte[] payload;new String(payload) 而且，乱码的问题不是必现，所以一直觉得代码没有问题，以至于问题总是得不到解决。后来仔细查找代码发现了，在字节数据解码成字符串数据的时候没有指定解码的格式，也就是和客户端统一的UTF-8，后来加上了UTF-8，问题得以解决 12byte[] payload;new String(payload， “UTF-8”) 仔细思考了为什么这个问题不是必现的原因，后来得出的结论是 1.如果代码本身不指定编码解码的格式，那么jvm可能会根据当前开发平台的编码格式来编码解码 2.如果代码本身不指定编码解码的格式，那么jvm可能随机选择解码的格式，所以才会导致有时候不乱码，有时候又乱码的现象。 总结:编码解码的格式一定要统一，这样才能保证客户端和服务端不会出现乱码的问题 #附录 用8个可以开合的晶体管来组合成不同的状态 Ascii编码（American Standard Code for information interchange） 0x20（0010 0000）即编号从0到32的编码规定了特殊的用途，称为“控制码 ” 然后剩下的编码是编码的空格，标点符号，数字，大小写字母，一直编码到了127号 ，这样计算机就可以用不同的字节来存储英语的文字了。 美帝国主义在创造计算机的时候可能没有考虑到其他国家的文字也会被用到计算机中把，也可能人家觉得其他国家的人不会用。所以没有留出多余的位置表示其他的字符。 后来，世界各地的人都在使用计算机，有些国家使用的不是英文，他们的字母里面有许多是Ascii里面没有的。为了可以在计算机中保存他们的文字。他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了许多画表格时需要用到的横线，竖线，交叉等形状，一直把序号编到了最后一个状态255，从128到255这一页的字符集被称&lt;扩展字符集&gt; 等到我们中国人民使用计算机的时候，已经没有可以利用的字节状态来表示汉字 况且有6000多个常用汉字需要保存，中国人民是聪明的，我们取消掉了127号之后的奇异符号。 ###GB2312的由来 规定：一个小于127的字符的意义与原来是相同的,&lt;但是两个大于127的字符连在一起的时候，就表示一个汉字了&gt;,前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样子我们就能够组合出大约7000多个简体汉字了，在这些编码里面，我们还把数学符号，罗马希腊的字母，日文的假名都编进去了，连载ASCII里面本来就有的数字，标点，字母都统统重新编码了两个字节长的编码，这就是常说的&lt;全角&gt;字符，而原来在127号一下的那些就叫做&lt;半角&gt;字符了，然后中国人名就把这种定义汉字的方案叫做。所有GB2312是对ASCII的中文扩展 GBK的由来 没办法，中国的汉字太多了，我们很快就发现了许多人的人名没有办法打印出来，于是不得不继续把GB2312没有用到的码位找出来用上，后来还是不够用，然后继续降低要求，不再要求低字节一定是127号后的内码，只要第一个字节（高字节）是大于127就固定表示这是一个汉字的开始,不管后面跟的失败不是扩展字符集里的内容，扩展之后的编码方案被称为GBK标准，GBK包括了GB2312的所有内容，同事又增加了近20000个新的汉字（包括繁体字）和符号，后来少数名族也要用电脑了，于是继续扩展，又新加了几千个新的少数名族的字，GBK扩展成了GB18030，中国的程序员把这种汉字的编码方案叫做DBCS（Double Byte Charecter Set 双字节字符集），在DBCS系列标准里面，最大的特点是两字节长的汉字字符和一字节厂的英文字符并存于同一套编码方案里面，为了支持中文的处理，必须要注意字符串里面每一个字节的值，如果这个值是大于127的，那么认为一个双字节字符集里面的字符出现了。 unicode的由来 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果相互之间谁也不懂谁的编码，谁也不支持别人的编码。 这时候，就出现了一个叫ISO（国际标准化组织）的国际组织决定着手解决这个问题，他们采用的方法很简单：废了所有的地区性编码，重新搞了一个包括了地球上所有文化，所有字母和符号的编码，名字全称叫做,简称UCS ，俗称“unicode” unicode开始制定的时候，计算机的存储器容量极大的发展了，空间再也不是问题了。于是ISO就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里面的那些“半角”字符，unicode保持其原来的编码不变，只是将其长度由原来的8位扩展为16位。而其他文化和语言的字符则全部重新统一编码。由于“半角”英文符号只需要用到低8位，所以其高八位永远都是0，因此这种大气的方案在保存英文文本的时候会多浪费一倍的空间 缺点: 如何才能区别unicode和ascii呢，计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？ 我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用3到4个字节，那么英文字母前民都必然会出现2到3个字节的0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出2、3倍。 解决办法： unicode英文这个原因在很长一段时间内都无法推广，知道互联网的出现，为解决unicode如何在网络上的问题，于是面向传输的众多UTF(UCS Transfer Fromat) 标准出现了，顾名思义，UTF-8就是每次8个位传输数据，UTF-16就是每次16个位，UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界 UTF-8详解 UTF-8最大的一个特点，就是它可以变长来编码。它可以使用1-4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码作为它的一部分，注意的是&lt;unicode一个中文字符占2个字节,而UTF-8一个中文字符占3个字节&gt;,从unicode到utf-8并不是直接的对应，而是要通过一些算法和规则来转换，具体的转换算法网上有很多，感兴趣的可以自行搜索看看]]></content>
      <categories>
        <category>bug修正记录</category>
      </categories>
      <tags>
        <tag>encode_bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis书籍观后感]]></title>
    <url>%2F2018%2F03%2F26%2Fmybatis%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[一直在使用的mybatis最近感觉自己对它了解的还是不够深，以前在项目中碰到了mybatis相关的问题只是百度一下，看看博客来解决问题。但是现在发现这对于以后的深入使用是远远不够的，所以决定好好的看看书，吸收一下更深一点的关于mybatis的知识 123today is mondaylet&apos;s begin to study mybatis 自动映射参数autoMappingBehavior,当它不设置为none的时候，Mybatis会提供自动映射的功能，只要返回的SQL列名和javabean的属性一直，mybatis就会帮助我们回填这些字段而无需任何配置，大部分的数据库规范都是要求每个单词用下划线分割，而java则是采用驼峰命名法来命名，于是使用类的别名就可以似的mybatis自动映射，或者直接在配置文件中开启驼峰命名方式 自动映射可以在settings元素中配置autoMappingBehavior属性值来设置其策略，它包含三个值 NONE，取消自动映射 PARTIAL，只会自动映射，没有定义嵌套结果集映射的结果集 FULL，会自动映射任意复杂的结果集（无论是否嵌套） 默认是PARTIAL,开启FULL是嵌套映射，在性能上会下降 多参数问题的解决方式当我们需要传递多个参数给映射器的时候，解决方式主要有一下几种 #####javaBean 12345678910111213141516171819202122232425262728293031package com.lgeek.smartHotel.params.Rolepublic class Role &#123; private Long id; private String roleName; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125;&#125; 使用map传递参数映射器xml文件123&lt;select id = "findRoleByMap" parameterType = "map" resultMap = "roleMap"&gt; select id, role_name, note from t_role where role_name like concat ('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')&lt;/select&gt; 映射器接口123456public interface RoleMapper&#123; /** *这里也可以以注解的形式来替代上面的xml文件执行相应的sql操作 */ public List&lt;Role&gt; findRoleMap(Map&lt;String ,String&gt; params);&#125; 执行的java代码1234Map&lt;String, String&gt; paramsMap = new HashMap&lt;String, String&gt;paramsMap.put("roleName", "me");paramsMap.put("note", "he");roleMapper.findRoleMap(paramsMap); 这总方式虽然简单易用，但是有弊端，这种参数使用了map，map是键对值得形式，业务的关联性不强，你需要深入到程序中看代码，造成可读性下降 ####使用注解传递参数 需要使用MyBatis的参数注解@Param(org.apache.ibatis.annotations.Param) 映射器接口123456public interface RoleMapper&#123; /** *这里也可以以注解的形式来替代上面的xml文件执行相应的sql操作 */ public List&lt;Role&gt; findRoleMap(@Param("roleName") String roleName, @Param("note") String note);&#125; 映射器xml文件此种方式无需定义参数类型在xml文件里面 123&lt;select id = "findRoleByMap" resultMap = "roleMap"&gt; select id, role_name, note from t_role where role_name like concat ('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')&lt;/select&gt; 这种方式可读性比较高，但是当参数比较多的情况下，参数就十分复杂了，可读性依旧也不高。这种情况下，mybatis为我们提供了使用JavaBean来定义参数 使用JavaBean来传递参数映射器接口1public List&lt;Role&gt; findRoleMap(Role role); 映射器xml文件此处的parameterType也可以使用别名，在mybatis上下文种配置的使用名称 123&lt;select id = "findRoleByMap" parameterType = “com.lgeek.smartHotel.params.Role” resultMap = "roleMap"&gt; select id, role_name, note from t_role where role_name like concat ('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')&lt;/select&gt; 总结:map传递参数，造成了业务可读性的丧失，而且不好扩展，也不好维护，当参数大于五个的时候，建议采用JavaBean的方式传递参数 resultMap结果映射集简单了解其本身是一个很强大的自定义映射的工具 映射器xml文件中定义resultMap123456789&lt;resultMap id = "roleMap" type = "com.lgeek.smartHotel.params.Role"&gt; &lt;id property = "id", column = "id"/&gt; &lt;result property = "roleName", column = "role_name"/&gt; &lt;result property = "note", column = "note"/&gt;&lt;/resultMap&gt;&lt;select id = "findRoleByMap" parameterType = “com.lgeek.smartHotel.params.Role” resultMap = "roleMap"&gt; select id, role_name, note from t_role where role_name like concat ('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')&lt;/select&gt; resultMap配置详解 type也可是使用别名（在mybatis上下文种定义的一个代表Role.java文件的名称） id元素代表着这个对象哪个属性代表主键，result元素定义普通列的映射关系，例如：把SQL结果返回的列role_name和javaBean的属性roleName定义起来 这样select语句就不需要再使用自动映射的规则，这样mybatis就会使用我们自己定义的映射规则 resultMap是映射器里面最为复杂的元素，他一般用于复杂，级联这些配置，后续博客会对此深入讲解。 typeHandler详解mybatis为我们注册了多个typeHander org.apache.ibatis.type.TypeHandlerRegistry 类型处理器 java类型 JDBC类型 BooleanTypeHandler Java.lang.Boolean,boolean 数据库兼容的BOOLEAN ByteTypeHandler Java.lang.Byte,byte 数据库兼容的NUMERIC,BYTE ShortTypeHandler Java.lang.Short,short 数据库兼容的NUMERIC,SHORT INTEGER ……. ……. ……. 具体详细typeHander对照表网上有很多，可以自行搜索 有以下细节需要注意 数值类型的精度，数据库int,double,decimal这些类型和java的精度，长度都是不一样的 时间精度，取数据到日用DateOnlyTypeHandler即可，用到精度为秒的用SqlTimestampTypeHandler等 typeHandler123456789101112131415161718192021public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatemenet ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i ,parameter); &#125; @Override public void getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public void getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public void getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; StringTypeHandler继承BaseTypeHandler实现TypeHandler(自己定义了四个抽象方法)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于使用hexo框架加上next主题借助github搭建博客遇到的坑]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E5%8A%A0%E4%B8%8Anext%E4%B8%BB%E9%A2%98%E5%80%9F%E5%8A%A9github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[坑first 这个坑是在搭建完之后，新建第一个博客文章的时候出现的 编辑博客使用的工具是Typora,语言是markdown 编辑完了之后hexo g 生成的时候就会报错，报错内容如下 123456789101112131415161718192021222324YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1: ^ at generateError (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:165:10) at throwError (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:171:9) at readBlockMapping (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1046:9) at composeNode (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1332:12) at readDocument (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1492:3) at loadDocuments (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1548:5) at Object.load (/Users/shucan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1569:19) at parseYAML (/Users/shucan/blog/node_modules/hexo-front-matter/lib/front_matter.js:80:21) at parse (/Users/shucan/blog/node_modules/hexo-front-matter/lib/front_matter.js:56:12) at Promise.all.spread (/Users/shucan/blog/node_modules/hexo/lib/plugins/processor/post.js:52:20) at tryCatcher (/Users/shucan/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:509:35) at Promise._settlePromise (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:693:18) at Promise._fulfill (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:638:18) at PromiseArray._resolve (/Users/shucan/blog/node_modules/bluebird/js/release/promise_array.js:126:19) at PromiseArray._promiseFulfilled (/Users/shucan/blog/node_modules/bluebird/js/release/promise_array.js:144:14) at PromiseArray._iterate (/Users/shucan/blog/node_modules/bluebird/js/release/promise_array.js:114:31) at PromiseArray.init [as _init] (/Users/shucan/blog/node_modules/bluebird/js/release/promise_array.js:78:10) at Promise._settlePromise (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:566:21) at Promise._settlePromise0 (/Users/shucan/blog/node_modules/bluebird/js/release/promise.js:614:10) 在网上百般搜索，一直以为是各种配置文件语法有误，所以一直在看配置文件，当然最后也没有解决问题 就在万般无奈之际，我尝试着打开了自己所编辑的博客，用Typora打开的 在新建的page里面，文章最前面的三个标签title,date,tags的值得填写也需要遵守和配置文件一样的格式，在标签和值之间，也就是冒号之后需要有一个空格。 问题不大，只是有时候很容易被忽略，而且编译的时候报错了也不能够直接定位到这个错误的地方。所以记录一下以防以后再碰到。也希望能为大家所用！]]></content>
      <tags>
        <tag>坑走的越多，处理事情就越能够游刃有余，当然，要时刻保持自信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小知识点积累]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[Integer类型，即包装类型进行比较大小的时候哦一些注意事项 使用valueOf方法创建的Integer对象，使用“==”符号时，运行结果有时候正确，有时候不正确。查看valueOf方法的源码，如下 1234567891011public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; 123456通过看源码能够知道，整数类型在-128～127之间时，会使用缓存，造成的效果就是，如果已经创建了一个相同的整数，使用valueOf创建第二次时， 不会使用new关键字，而用已经缓存的对象。所以使用valueOf方法创建两次对象，若对应的数值相同，且数值在-128～127之间时，两个对象都指 向同一个地址。最后，使用Integer i = 400这样的方式来创建Integer对象，与valueOf方法的效果是一样的，不再赘述。总之，包装类对象不可使用“==”符做比较运算，如果要进行比较运算时，最好使用java类库中的compareTo方法]]></content>
      <tags>
        <tag>不积小流，无以成江河</tag>
      </tags>
  </entry>
</search>
